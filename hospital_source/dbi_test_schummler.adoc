= XPath, XQuery and XSD

== XPath

=== Command Overview

<foo baz="5"><bar>25</bar></foo>

|===
|Command |Meaning

|/foo/bar
|Selects all bar's of foo (with foo as a parent of bar)

|//bar
|Select all bar’s (in the whole document

|/foo[bar>20]
|Sub-Element (child) condition for foo filtering

|foo[@baz<10]
|Attribute condition for foo filtering

|last()
|Gets the last element
|===


== XQuery

XQuery is a superset of XPath

=== Quick overview
----
for $x in doc("books.xml")/books/book
where $x/price>30
order by $x/title
return $x/title
----

=== FLOWR

* For
* Let
* Where
* Order
* Return


=== Command Overview

|===
|Command |Meaning

|for $x in [doc() ¦ XPath expr.]
|Define data source and ’row’ variable

|let $n := <a value>
|Assigns a value (values) to a variable

|where $x <condition>
|Filters ’rows’ fulfilling the condition

|order by $x [descending]
|Orders the remaining ’rows’

|return $x[/foo ¦ /@bar]
|Returns the ’row’ or a subset of it

|functx:line-count($x)
|Returns the line count

|sum()
|Returns the sum

|===

=== Examples

----
for $b in //book
where $b/@id = 2 or $b/year > 2015
return $b/title
----

-> Returns the titles of the books which have the id 2 or were written after 2015


----
for $b in //book
where fn:tokenize($b/[author])[2] = ’Knuth’
return ($b/price, $b/year)
----

-> You can return multiple values

== XSD

=== Beispiel mit Begriffserklärung

[source,xml]
----
<?xml version="1.0" encoding="ISO-8859-1"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
xmlns="http://meinnamespace.meinefirma.de"
targetNamespace="http://meinnamespace.meinefirma.de"
elementFormDefault="qualified">
<xs:element name="adressen">
<xs:complexType>
<xs:sequence>
<xs:element name="adresse" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:sequence>
<xs:element name="firma" minOccurs="0"> <xs:complexType /> </xs:element>
<xs:element name="name"  type="xs:string" />
<xs:choice>
<xs:element name="strasse"  type="xs:string" minOccurs="0" />
<xs:element name="postfach" type="xs:positiveInteger" minOccurs="0" />
</xs:choice>
<xs:element name="plz" type="xs:positiveInteger" minOccurs="0" />
<xs:element name="ort" type="xs:string" minOccurs="0" />
</xs:sequence>
<xs:attribute name="datum" type="xs:date" />
</xs:complexType>
</xs:element>
</xs:sequence>
</xs:complexType>
</xs:element>
</xs:schema>
----

https://www.torsten-horn.de/techdocs/java-xsd.htm

element: Definiert die einzelnen XML-Elemente.

sequence: Definiert eine geordnete Struktur mit fester Reihenfolge. Die Alternative wäre all.

minOccurs und maxOccurs: Wenn diese Angaben fehlen, muss das Element genau einmal vorhanden sein. minOccurs="0" erlaubt das Fehlen dieses Elements. maxOccurs="unbounded" erlaubt eine beliebige Anzahl der Elemente.

attribute: Definiert Attribute (alternativ zum element).

xs:string, xs:positiveInteger, xs:date: Vordefinierte Datentypen.

complexType: Definiert kompliziertere Elemente, z.B. Elemente mit Kindelementen und/oder Attributen. Beachten Sie, dass auch das leere firma-Element als complexType definiert wird, allerdings als leerer. Falls außer Kindelementen und/oder Attributen auch ein Elementinhalt erlaubt sein soll, muss mixed="true" gesetzt werden.

Die Kindselemente werden nicht lokal definiert, sondern per ref referenziert.

=== Enumeration

[source,xml]
----
<xs:simpleType name="color" final="restriction"
>
<xs:restriction base="xs:string">
<xs:enumeration value="green" />
<xs:enumeration value="red" />
<xs:enumeration value="blue" />
</xs:restriction>
</xs:simpleType>
----

=== Range Constraint

[source, xml]
----
<xs:element name="age">
<xs:simpleType>
<xs:restriction base="xs:integer">
<xs:minInclusive value="0"/>
<xs:maxInclusive value="100"/>
</xs:restriction>
</xs:simpleType>
</xs:element>
----
